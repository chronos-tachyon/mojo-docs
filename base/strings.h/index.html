<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>base/strings.h : Mojo</title>
  <link rel="sitemap" type="text/xml" href="../../sitemap.xml">
  <link rel="icon" type="image/png" href="../../.img/favicon.png">
  <link rel="stylesheet" type="text/css" href="../../.css/lity-1.6.6.min.css">
  <link rel="stylesheet" type="text/css" href="../../.css/style.css">
  <script src="../../.js/jquery-3.1.0.slim.min.js" defer></script>
  <script src="../../.js/lity-1.6.6.min.js" defer></script>
  <script src="../../.js/nav.js" defer></script>
</head>
<body>
  <article id="main">
    <header>
      <p><a href="../../">Mojo</a> &gt; <a href="../">base</a> &gt;</p>
      <h1>strings.h</h1>
    </header>

    <p>GitHub:
    <a href="https://github.com/chronos-tachyon/mojo/blob/master/base/strings.h">base/strings.h</a>
    <a href="https://github.com/chronos-tachyon/mojo/blob/master/base/strings.cc">base/strings.cc</a>
    </p>

    <div id="toc">
      Waiting on JavaScript...
    </div>

    <section>
      <h2 id="functions">Top-level Functions</h2>

      <h3 id="helpers">StringPiece Helpers</h3>

      <h4 id="compare">compare()</h4>
      <p>TODO: fill this in.</p>

      <h4 id="substring">substring()</h4>
      <p>TODO: fill this in.</p>

      <h4 id="prefix">prefix()</h4>
      <p>TODO: fill this in.</p>

      <h4 id="suffix">suffix()</h4>
      <p>TODO: fill this in.</p>

      <h4 id="has_prefix">has_prefix()</h4>
      <p>TODO: fill this in.</p>

      <h4 id="has_suffix">has_suffix()</h4>
      <p>TODO: fill this in.</p>

      <h4 id="strip_prefix">strip_prefix()</h4>
      <p>TODO: fill this in.</p>

      <h4 id="strip_suffix">strip_suffix()</h4>
      <p>TODO: fill this in.</p>

      <h3 id="split-and-join">Splitters and Joiners</h3>

      <h4 id="split-fixed_length">split::fixed_length()</h4>
      <p>TODO: fill this in.</p>

      <h4 id="split-on">split::on()</h4>
      <p>TODO: fill this in.</p>

      <h4 id="split-on_pattern">split::on_pattern()</h4>
      <p>TODO: fill this in.</p>

      <h4 id="join-on">join::on()</h4>
      <p>TODO: fill this in.</p>
    </section>
    <hr>
    <section>
      <h2 id="StringPiece">StringPiece</h2>

<pre class="codebox">
namespace base {

class <strong>StringPiece</strong> {
 public:
  using value_type = char;
  using const_reference = const char&amp;;
  using const_pointer = const char*;
  using const_iterator = const char*;
  using const_reverse_iterator = <a href="http://en.cppreference.com/w/cpp/iterator/reverse_iterator">std::reverse_iterator</a>&lt;const_iterator&gt;;
  using reference = const_reference;
  using pointer = const_pointer;
  using iterator = const_iterator;
  using reverse_iterator = const_reverse_iterator;
  using size_type = std::size_t;
  using difference_type = std::ptrdiff_t;

  static constexpr size_type npos;

  constexpr <a href="#StringPiece-ctor">StringPiece</a>() noexcept;
  constexpr <a href="#StringPiece-ctor">StringPiece</a>(const StringPiece&amp;) noexcept;
  constexpr <a href="#StringPiece-ctor">StringPiece</a>(StringPiece&amp;&amp;) noexcept;
  constexpr <a href="#StringPiece-ctor">StringPiece</a>(const_pointer ptr, size_type len) noexcept;
  constexpr <a href="#StringPiece-ctor">StringPiece</a>(const_pointer ptr) noexcept;
  template &lt;std::size_t N&gt; constexpr <a href="#StringPiece-ctor">StringPiece</a>(const char arr[N]) noexcept;
  <a href="#StringPiece-ctor">StringPiece</a>(const <a href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a>&amp; str) noexcept;
  <a href="#StringPiece-ctor">StringPiece</a>(const <a href="http://en.cppreference.com/w/cpp/container/vector">std::vector</a>&lt;char&gt;&amp; vec) noexcept;
  <a href="#StringPiece-ctor">StringPiece</a>(<a href="https://github.com/google/re2/blob/master/re2/stringpiece.h">re2::StringPiece</a> sp) noexcept;

  StringPiece&amp; <a href="#StringPiece-opeq">operator=</a>(const StringPiece&amp;) noexcept;
  StringPiece&amp; <a href="#StringPiece-opeq">operator=</a>(StringPiece&amp;&amp;) noexcept;

  constexpr bool <a href="#StringPiece-empty">empty</a>() const noexcept;
  constexpr const_pointer <a href="#StringPiece-data">data</a>() const noexcept;
  constexpr size_type <a href="#StringPiece-size">size</a>() const noexcept;

  constexpr const_iterator <a href="#StringPiece-begin-end">begin</a>() const noexcept;
  constexpr const_iterator <a href="#StringPiece-begin-end">end</a>() const noexcept;
  constexpr const_iterator <a href="#StringPiece-cbegin-cend">cbegin</a>() const noexcept;
  constexpr const_iterator <a href="#StringPiece-cbegin-cend">cend</a>() const noexcept;

  const_reverse_iterator <a href="#StringPiece-rbegin-rend">rbegin</a>() const noexcept;
  const_reverse_iterator <a href="#StringPiece-rbegin-rend">rend</a>() const noexcept;
  const_reverse_iterator <a href="#StringPiece-crbegin-crend">crbegin</a>() const noexcept;
  const_reverse_iterator <a href="#StringPiece-crbegin-crend">crend</a>() const noexcept;

  constexpr const_reference <a href="#StringPiece-front">front</a>() const noexcept;
  constexpr const_reference <a href="#StringPiece-back">back</a>() const noexcept;
  constexpr const_reference <a href="#StringPiece-opindex">operator[]</a>(size_type i) const noexcept;

  constexpr int <a href="#StringPiece-compare">compare</a>(StringPiece other) const noexcept;

  constexpr StringPiece <a href="#StringPiece-substring">substring</a>(size_type pos, size_type len = npos) const noexcept;
  constexpr StringPiece <a href="#StringPiece-prefix">prefix</a>(size_type n) const noexcept;
  constexpr StringPiece <a href="#StringPiece-suffix">suffix</a>(size_type n) const noexcept;
  constexpr StringPiece <a href="#StringPiece-strip_prefix">strip_prefix</a>(size_type len) const noexcept;
  constexpr StringPiece <a href="#StringPiece-strip_suffix">strip_suffix</a>(size_type len) const noexcept;
  constexpr StringPiece <a href="#StringPiece-strip_prefix">strip_prefix</a>(StringPiece sp) const noexcept;
  constexpr StringPiece <a href="#StringPiece-strip_suffix">strip_suffix</a>(StringPiece sp) const noexcept;

  void <a href="#StringPiece-remove_prefix">remove_prefix</a>(size_type n) noexcept;
  void <a href="#StringPiece-remove_suffix">remove_suffix</a>(size_type n) noexcept;
  bool <a href="#StringPiece-remove_prefix">remove_prefix</a>(StringPiece sp) noexcept;
  bool <a href="#StringPiece-remove_suffix">remove_suffix</a>(StringPiece sp) noexcept;
  template &lt;typename Func&gt; void <a href="#StringPiece-trim">trim</a>(Func func);
  void <a href="#StringPiece-trim">trim</a>(char ch);
  void <a href="#StringPiece-trim">trim_whitespace</a>();
  template &lt;typename Func&gt; void <a href="#StringPiece-ltrim">ltrim</a>(Func func);
  void <a href="#StringPiece-ltrim">ltrim</a>(char ch);
  void <a href="#StringPiece-ltrim">ltrim_whitespace</a>();
  template &lt;typename Func&gt; void <a href="#StringPiece-rtrim">rtrim</a>(Func func);
  void <a href="#StringPiece-rtrim">rtrim</a>(char ch);
  void <a href="#StringPiece-rtrim">rtrim_whitespace</a>();

  constexpr bool <a href="#StringPiece-contains">contains</a>(StringPiece sp) const noexcept;
  constexpr bool <a href="#StringPiece-has_prefix">has_prefix</a>(StringPiece sp) const noexcept;
  constexpr bool <a href="#StringPiece-has_suffix">has_suffix</a>(StringPiece sp) const noexcept;
  constexpr size_type <a href="#StringPiece-find">find</a>(char ch, size_type pos = 0) const noexcept;
  constexpr size_type <a href="#StringPiece-find">find</a>(StringPiece sp, size_type pos = 0) const noexcept;
  constexpr size_type <a href="#StringPiece-rfind">rfind</a>(char ch, size_type pos = npos) const noexcept;
  constexpr size_type <a href="#StringPiece-rfind">rfind</a>(StringPiece sp, size_type pos = npos) const noexcept;

  void <a href="#StringPiece-append_to">append_to</a>(<a href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a>* out) const;
  std::size_t <a href="#StringPiece-length_hint">length_hint</a>() const noexcept;
  <a href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a> <a href="#StringPiece-as_string">as_string</a>() const;
  <a href="#StringPiece-opstring">operator std::string</a>() const;
  <a href="#StringPiece-opre2sp">operator re2::StringPiece</a>() const noexcept;
};

std::ostream&amp; <a href="#StringPiece-opltlt">operator&lt;&lt;</a>(std::ostream&amp; o, StringPiece sp);

constexpr bool <a href="#StringPiece-opeqeq">operator==</a>(StringPiece a, StringPiece b) noexcept;
constexpr bool <a href="#StringPiece-opnoteq">operator!=</a>(StringPiece a, StringPiece b) noexcept;
constexpr bool <a href="#StringPiece-oplt">operator&lt;</a>(StringPiece a, StringPiece b) noexcept;
constexpr bool <a href="#StringPiece-oplteq">operator&lt;=</a>(StringPiece a, StringPiece b) noexcept;
constexpr bool <a href="#StringPiece-opgt">operator&gt;</a>(StringPiece a, StringPiece b) noexcept;
constexpr bool <a href="#StringPiece-opgteq">operator&gt;=</a>(StringPiece a, StringPiece b) noexcept;

}
</pre>

      <p>RC. StringPiece is a value type consisting of a pointer to
      <code>const char</code> and a length. It represents a string or a piece
      of a string. Take a StringPiece by value where you would normally take a
      <code>const&nbsp;std::string&amp;</code>, especially in situations where
      you don't need a <code>std::string</code> or NUL-termination.</p>

      <p><strong>NOTE</strong>: StringPiece values are <strong>NOT</strong>
      NUL-terminated.</p>

      <p><strong>NOTE</strong>: StringPiece does <strong>NOT</strong>
      own the memory it points to. It is the caller's responsibility to ensure
      that the region of memory pointed to remains valid for the lifetime of
      the StringPiece.</p>

      <p><strong>NOTE</strong>: If a StringPiece's <code>size()</code> is 0,
      then its <code>data()</code> pointer may be <code>NULL</code>.</p>

      <h3 id="StringPiece-ctor">StringPiece::StringPiece()</h3>

      <p>Constructs a StringPiece.</p>

      <ul>
        <li>
          The default constructor creates a StringPiece with a
          <code>data()</code> of <code>NULL</code> and a <code>size()</code>
          of 0.
        </li>
        <li>
          The copy constructor copies the literal pointer and size of the
          copied-from object. The pointed-to string is not copied.
        </li>
        <li>
          The move constructor is indistinguishable from the copy constructor.
        </li>
        <li>
          The 2-arg constructor creates a StringPiece with the given
          <code>data()</code> and <code>size()</code>.
        </li>
        <li>
          The 1-arg <code>const&nbsp;char*</code> constructor takes the given
          NUL-terminated string as <code>data()</code> and its length as
          <code>size()</code>.
        </li>
        <li>
          The templated <code>const&nbsp;char[N]</code> constructor takes the
          given NUL-terminated char array as <code>data()</code> and
          <code>N&nbsp;-&nbsp;1</code> as <code>size()</code>.
        </li>
        <li>
          The <code>const&nbsp;std::string&amp;</code> constructor takes the
          <code>data()</code> and <code>size()</code> of the provided string
          as its own <code>data()</code> and <code>size()</code>.
        </li>
        <li>
          The <code>const&nbsp;std::vector&lt;char&gt;&amp;</code> constructor
          takes the <code>data()</code> and <code>size()</code> of the
          provided vector as its own <code>data()</code> and
          <code>size()</code>.
        </li>
        <li>
          The
          <a href="https://github.com/google/re2/blob/master/re2/stringpiece.h"><code>re2::StringPiece</code></a>
          constructor takes the <code>data()</code> and <code>size()</code> of
          the provided <code>re2::StringPiece</code> as its own
          <code>data()</code> and <code>size()</code>.
        </li>
      </ul>

      <h3 id="StringPiece-opeq">StringPiece::operator=()</h3>

      <p>Assigns to this StringPiece. The copy and move assignment operators
      function analogously to the copy constructor.</p>

      <h3 id="accessors">Accessors</h3>

      <h4 id="StringPiece-empty">StringPiece::empty()</h4>

      <p>Returns true iff this StringPiece has <code>size()</code> 0.</p>

      <h4 id="StringPiece-data">StringPiece::data()</h4>

      <p>Returns this StringPiece's pointer.</p>

      <p>If <code>size()</code> is 0, then this pointer may be
      <code>NULL</code>.</p>

      <h4 id="StringPiece-size">StringPiece::size()</h4>

      <p>Returns this StringPiece's size.</p>

      <h3 id="iterators">Iterators</h3>

      <h4 id="StringPiece-begin-end">StringPiece::begin() / StringPiece::end()</h4>

      <p>Iterates over the characters of this StringPiece's string.</p>

      <h4 id="StringPiece-cbegin-cend">StringPiece::cbegin() / StringPiece::cend()</h4>

      <p>Alias for <code>begin()</code> / <code>end()</code>.</p>

      <h4 id="StringPiece-rbegin-rend">StringPiece::rbegin() / StringPiece::rend()</h4>

      <p>Reverse iterates over the characters of this StringPiece's
      string.</p>

      <h4 id="StringPiece-crbegin-crend">StringPiece::crbegin() / StringPiece::crend()</h4>

      <p>Alias for <code>rbegin()</code> / <code>rend()</code>.</p>

      <h3 id="indexing">Indexing</h3>

      <h4 id="StringPiece-front">StringPiece::front()</h4>

      <p>Returns a reference to this StringPiece's first character.</p>

      <p>PRECONDITION: <code>!empty()</code></p>

      <h4 id="StringPiece-back">StringPiece::back()</h4>

      <p>Returns a reference to this StringPiece's last character.</p>

      <p>PRECONDITION: <code>!empty()</code></p>

      <h4 id="StringPiece-opindex">StringPiece::operator[]()</h4>

      <p>Returns a reference to this StringPiece's i'th character.</p>

      <p>PRECONDITION: <code>i&nbsp;&lt;&nbsp;size()</code></p>

      <h3 id="comparing">Comparing</h3>

      <h4 id="StringPiece-compare">StringPiece::compare()</h4>

      <p>Compares this StringPiece with the other. Returns a value less than 0
      if this StringPiece compares less than the other, a value greater than 0
      if this StringPiece compares greater than the other, or 0 if the two
      StringPieces compare equal.</p>

      <h4 id="StringPiece-opeqeq">StringPiece::operator==()</h4>
      <h4 id="StringPiece-opnoteq">StringPiece::operator!=()</h4>
      <h4 id="StringPiece-oplt">StringPiece::operator&lt;()</h4>
      <h4 id="StringPiece-oplteq">StringPiece::operator&lt;=()</h4>
      <h4 id="StringPiece-opgt">StringPiece::operator&gt;()</h4>
      <h4 id="StringPiece-opgteq">StringPiece::operator&gt;=()</h4>

      <p>Compares two StringPieces.</p>

      <h3 id="substrings">Substrings</h3>

      <h4 id="StringPiece-substring">StringPiece::substring()</h4>

      <p>Returns a StringPiece which is a substring of this StringPiece. If
      both arguments are in range, the substring will begin <code>pos</code>
      bytes past the start of this StringPiece, and will be <code>len</code>
      bytes long.</p>
      
      <ul>
        <li>
          If the <code>pos</code> argument would begin past the end of the
          string, then the function behaves as if <code>pos</code> were
          <code>size()</code>.
        </li>
        <li>
          If the <code>len</code> argument is larger than the number of
          bytes remaining between <code>pos</code> and <code>size()</code>,
          then <code>len</code> is reduced to the number of remaining bytes.
        </li>
      </ul>

      <h4 id="StringPiece-prefix">StringPiece::prefix()</h4>

      <p>Returns a StringPiece which is a prefix of this StringPiece. If
      <code>len&nbsp;&lt;=&nbsp;size()</code>, returns the first
      <code>len</code> bytes; otherwise, returns the whole string.</p>

      <p>Equivalent to: <code>substring(0,&nbsp;len)</code>.</p>

      <h4 id="StringPiece-suffix">StringPiece::suffix()</h4>

      <p>Returns a StringPiece which is a suffix of this StringPiece. If
      <code>len&nbsp;&lt;=&nbsp;size()</code>, returns the last
      <code>len</code> bytes; otherwise, returns the whole string.</p>

      <p>Equivalent to: <code>substring(size()&nbsp;-&nbsp;len)</code>
      (assuming that <code>len</code> is in range)</p>

      <h4 id="StringPiece-strip_prefix">StringPiece::strip_prefix()</h4>

      <p>Variant #1: takes <code>std::size_t</code></p>

      <p>Returns a StringPiece which removes a prefix of this StringPiece. If
      <code>len&nbsp;&lt;=&nbsp;size()</code>, returns the last
      <code>size()&nbsp;-&nbsp;len</code> bytes; otherwise, returns an empty
      string positioned at <code>data()&nbsp;+&nbsp;size()</code>.</p>

      <p>Equivalent to: <code>substring(len)</code>.</p>

      <p>Variant #2: takes <code>StringPiece</code></p>

      <p>Returns a StringPiece which is like this StringPiece, but with the
      given prefix removed.</p>

      <p>Equivalent to:
      <code>x.has_prefix(sp)&nbsp;?&nbsp;x.strip_prefix(sp.size())&nbsp;:&nbsp;x</code>.</p>

      <h4 id="StringPiece-strip_suffix">StringPiece::strip_suffix()</h4>

      <p>Variant #1: takes <code>std::size_t</code></p>

      <p>Returns a StringPiece which removes a suffix of this StringPiece. If
      <code>len&nbsp;&lt;=&nbsp;size()</code>, returns the first
      <code>size()&nbsp;-&nbsp;len</code> bytes; otherwise, returns an empty
      string positioned at <code>data()</code>.</p>

      <p>Equivalent to: <code>substring(0,&nbsp;size()&nbsp;-&nbsp;len)</code>
      (assuming that <code>len</code> is in range)</p>

      <p>Variant #2: takes <code>StringPiece</code></p>

      <p>Returns a StringPiece which is like this StringPiece, but with the
      given suffix removed.</p>

      <p>Equivalent to:
      <code>x.has_suffix(sp)&nbsp;?&nbsp;x.strip_suffix(sp.size())&nbsp;:&nbsp;x</code>.</p>

      <h3 id="trimming">Trimming</h3>

      <h4 id="StringPiece-remove_prefix">StringPiece::remove_prefix()</h4>

      <p>Variant #1: takes <code>std::size_t</code></p>

      <p>Removes the first <code>len</code> bytes from this StringPiece.</p>

      <p>Equivalent to: <code>x&nbsp;=&nbsp;x.strip_prefix(len);</code></p>

      <p>Variant #1: takes <code>StringPiece</code></p>

      <p>Removes the prefix <code>sp</code> from this StringPiece, if this
      StringPiece has such a prefix.</p>

      <p>Equivalent to:<br>
      <code>result&nbsp;=&nbsp;x.has_prefix(sp);</code><br>
      <code>if&nbsp;(result)&nbsp;x&nbsp;=&nbsp;x.strip_prefix(sp.size());</code></p>

      <h4 id="StringPiece-remove_suffix">StringPiece::remove_suffix()</h4>

      <p>Variant #1: takes <code>std::size_t</code></p>

      <p>Removes the last <code>len</code> bytes from this StringPiece.</p>

      <p>Equivalent to: <code>x&nbsp;=&nbsp;x.strip_suffix(len);</code></p>

      <p>Variant #1: takes <code>StringPiece</code></p>

      <p>Removes the suffix <code>sp</code> from this StringPiece, if this
      StringPiece has such a suffix.</p>

      <p>Equivalent to:<br>
      <code>result&nbsp;=&nbsp;x.has_suffix(sp);</code><br>
      <code>if&nbsp;(result)&nbsp;x&nbsp;=&nbsp;x.strip_suffix(sp.size());</code></p>

      <h4 id="StringPiece-trim">StringPiece::trim() / StringPiece::trim_whitespace()</h4>

      <p>Removes all matching bytes from both the beginning and the end of the
      StringPiece.</p>

      <p>Variant #1: takes <code>std::function&lt;bool(char)&gt;</code></p>

      <p>Removes all initial and final bytes for which <code>pred</code>
      returns true.</p>

      <p>Variant #2: takes <code>char</code></p>

      <p>Removes all initial and final occurrences of <code>ch</code>.</p>

      <p>Variant #3: <code>trim_whitespace()</code></p>

      <p>Removes all initial and final occurrences of ASCII HT, LF, VT, FF,
      CR, and/or SP.</p>

      <h4 id="StringPiece-ltrim">StringPiece::ltrim() / StringPiece::ltrim_whitespace()</h4>

      <p>Like <a href="#StringPiece-trim"><code>trim()</code></a>, but only
      affects initial ("left") occurrences.</p>

      <h4 id="StringPiece-rtrim">StringPiece::rtrim() / StringPiece::rtrim_whitespace()</h4>

      <p>Like <a href="#StringPiece-trim"><code>trim()</code></a>, but only
      affects final ("right") occurrences.</p>

      <h3 id="searching">Searching</h3>

      <h4 id="StringPiece-contains">StringPiece::contains()</h4>

      <p>Returns true iff this StringPiece contains a literal occurrence of
      <code>sp</code> within it.</p>

      <h4 id="StringPiece-has_prefix">StringPiece::has_prefix()</h4>

      <p>Returns true iff this StringPiece begins with a literal occurrence of
      <code>sp</code>.</p>

      <h4 id="StringPiece-has_suffix">StringPiece::has_suffix()</h4>

      <p>Returns true iff this StringPiece ends with a literal occurrence of
      <code>sp</code>.</p>

      <h4 id="StringPiece-find">StringPiece::find()</h4>

      <p>Returns the index of the first ("leftmost") occurrence of
      <code>ch</code> or <code>sp</code> that begins at or after offset
      <code>pos</code>, or return <code>StringPiece::npos</code> if no such
      index could be found.</p>

      <h4 id="StringPiece-rfind">StringPiece::rfind()</h4>

      <p>Returns the index of the last ("rightmost") occurrence of <code>ch</code> or
      <code>sp</code> that begins at or before offset <code>pos</code>, or
      return <code>StringPiece::npos</code> if no such index could be
      found.</p>

      <h3 id="stringification">Stringification</h3>

      <h4 id="StringPiece-append_to">StringPiece::append_to()</h4>

      <p>Stringifies this StringPiece and appends it to <code>out</code>.</p>

      <h4 id="StringPiece-length_hint">StringPiece::length_hint()</h4>

      <p>Returns the length of this StringPiece's stringification.</p>

      <h4 id="StringPiece-as_string">StringPiece::as_string()</h4>

      <p>Returns this StringPiece as a <code>std::string</code>.</p>

      <h4 id="StringPiece-opltlt">StringPiece::operator&lt;&lt;()</h4>

      <p>Outputs this StringPiece to the given <code>std::ostream</code>.</p>

      <h3 id="conversions">Conversions</h3>

      <h4 id="StringPiece-opstring">StringPiece::operator std::string()</h4>

      <p>Alternative to
      <a href="#StringPiece-as_string"><code>as_string()</code></a>.</p>

      <h4 id="StringPiece-opre2sp">StringPiece::operator re2::StringPiece()</h4>

      <p>Returns an
      <a href="https://github.com/google/re2/blob/master/re2/stringpiece.h"><code>re2::StringPiece</code></a>
      that has the same <code>data()</code> and <code>size()</code> as this
      StringPiece's <code>data()</code> and <code>size()</code>.</p>
    </section>
    <hr>
    <section>
      <h2 id="Splitter">Splitter</h2>

<pre class="codebox">
namespace base {

class <strong>Splitter</strong> {
 public:
  using Pointer = <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a>&lt;<a href="#SplitterImpl">SplitterImpl</a>&gt;;
  using Predicate = <a href="http://en.cppreference.com/w/cpp/utility/functional/function">std::function</a>&lt;bool(char)&gt;;

  <a href="#Splitter-ctor">Splitter</a>();
  <a href="#Splitter-ctor">Splitter</a>(Pointer ptr);
  <a href="#Splitter-ctor">Splitter</a>(const Splitter&amp;);
  <a href="#Splitter-ctor">Splitter</a>(Splitter&amp;&amp;);
  Splitter&amp; <a href="#Splitter-opeq">operator=</a>(const Splitter&amp;);
  Splitter&amp; <a href="#Splitter-opeq">operator=</a>(Splitter&amp;&amp;);

  <a href="#Splitter-opbool">explicit operator bool</a>() const noexcept;
  void <a href="#Splitter-assert_valid">assert_valid</a>() const noexcept;
  const Pointer&amp; <a href="#Splitter-implementation">implementation</a>() const noexcept;
  Pointer&amp; <a href="#Splitter-implementation">implementation</a>() noexcept;

  Splitter&amp; <a href="#Splitter-trim">trim</a>(Predicate pred);
  Splitter&amp; <a href="#Splitter-trim">trim</a>(char ch);
  Splitter&amp; <a href="#Splitter-trim">trim_whitespace</a>();
  Splitter&amp; <a href="#Splitter-limit">limit</a>(std::size_t n) noexcept;
  Splitter&amp; <a href="#Splitter-unlimited">unlimited</a>() noexcept;
  Splitter&amp; <a href="#Splitter-omit_empty">omit_empty</a>(bool value = true) noexcept;

  <a href="http://en.cppreference.com/w/cpp/container/vector">std::vector</a>&lt;<a href="#StringPiece">StringPiece</a>&gt; <a href="#Splitter-split">split</a>(StringPiece sp) const;
  <a href="http://en.cppreference.com/w/cpp/container/vector">std::vector</a>&lt;<a href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a>&gt; <a href="#Splitter-split">split_strings</a>(StringPiece sp) const;
};

}
</pre>

      <p>TODO: fill this in.</p>

      <h3 id="Splitter-ctor">Splitter::Splitter()</h3>

      <p>Constructs a Splitter.</p>

      <ul>
        <li>
          The default constructor creates an empty Splitter.
        </li>
        <li>
          The <code>Pointer</code> constructor creates a non-empty Splitter.
        </li>
        <li>
          The copy constructor creates a Splitter with the same implementation
          and knobs as the copied-from Splitter.
        </li>
        <li>
          The move constructor creates a Splitter with the same implementation
          and knobs as the moved-from Splitter. The moved-from Splitter is
          left as an empty Splitter.
        </li>
      </ul>

      <h3 id="Splitter-opeq">Splitter::operator=()</h3>

      <p>Assigns to this Splitter. The copy and move assignment operators
      function analogously to their respective constructors.</p>

      <h3 id="simplementation">Implementation</h3>

      <h4 id="Splitter-opbool">Splitter::operator bool()</h4>

      <p>Returns true iff this Splitter is non-empty.</p>

      <h4 id="Splitter-assert_valid">Splitter::assert_valid()</h4>

      <p>Asserts that this Splitter is non-empty.</p>

      <h4 id="Splitter-implementation">Splitter::implementation()</h4>

      <p>Returns the pointer to this Splitter's implementation.</p>

      <h3 id="sfluent">Fluent Setters</h3>

      <h4 id="Splitter-trim">Splitter::trim() / Splitter::trim_whitespace()</h4>

      <p>Configures this Splitter to remove all matching bytes from both the
      beginning and the end of each output item.</p>

      <p>Variant #1: takes <code>std::function&lt;bool(char)&gt;</code></p>

      <p>Removes all initial and final bytes for which <code>pred</code>
      returns true.</p>

      <p>Variant #2: takes <code>char</code></p>

      <p>Removes all initial and final occurrences of <code>ch</code>.</p>

      <p>Variant #3: <code>trim_whitespace()</code></p>

      <p>Removes all initial and final occurrences of ASCII HT, LF, VT, FF,
      CR, and/or SP.</p>

      <p>The default is not to trim.</p>

      <h4 id="Splitter-limit">Splitter::limit()</h4>

      <p>Places an upper limit on the number of items which can be produced in
      a single split.</p>

      <p><strong>NOTE</strong>: The value 0 is impossible; it is treated as if
      it were the value 1.</p>

      <p>The default is no upper limit.</p>

      <h4 id="Splitter-unlimited">Splitter::unlimited()</h4>

      <p>Removes any upper limit on the number of items which can be produced
      in a single split.</p>

      <p>The default is no upper limit.</p>

      <h4 id="Splitter-omit_empty">Splitter::omit_empty()</h4>

      <p>Iff <code>value</code> is true, configures this Splitter to omit any
      output item whose trimmed value is an empty string.</p>

      <p>The default is to yield any empty output items.</p>

      <h3 id="Splitter-split">Splitter::split() / Splitter::split_strings()</h3>

      <p>Splits a <a href="#StringPiece">StringPiece</a> into StringPiece or
      <code>std::string</code> values. In the StringPiece case, each
      StringPiece is a substring of the initial StringPiece.</p>
    </section>
    <hr>
    <section>
      <h2 id="SplitterImpl">SplitterImpl</h2>

<pre class="codebox">
namespace base {

class <strong>SplitterImpl</strong> {
 public:
  virtual ~SplitterImpl() noexcept = default;
  virtual bool <a href="#SplitterImpl-chop">chop</a>(<a href="#StringPiece">StringPiece</a>* first, <a href="#StringPiece">StringPiece</a>* rest,
                    <a href="#StringPiece">StringPiece</a> sp) const = 0;

  <s>SplitterImpl(const SplitterImpl&amp;) = delete;</s>
  <s>SplitterImpl(SplitterImpl&amp;&amp;) = delete;</s>
  <s>SplitterImpl&amp; operator=(const SplitterImpl&amp;) = delete;</s>
  <s>SplitterImpl&amp; operator=(SplitterImpl&amp;&amp;) = delete;</s>
}
</pre>

      <p>TODO: fill this in.</p>

      <h3 id="SplitterImpl-chop">SplitterImpl::chop()</h3>
    </section>
    <hr>
    <section>
      <h2 id="Joiner">Joiner</h2>

<pre class="codebox">
namespace base {

class <strong>Joiner</strong> {
 public:
  using Pointer = <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a>&lt;<a href="#JoinerImpl">JoinerImpl</a>&gt;;

  <a href="#Joiner-ctor">Joiner</a>();
  <a href="#Joiner-ctor">Joiner</a>(Pointer ptr);
  <a href="#Joiner-ctor">Joiner</a>(const Joiner&amp;);
  <a href="#Joiner-ctor">Joiner</a>(Joiner&amp;&amp;);
  Joiner&amp; <a href="#Joiner-opeq">operator=</a>(const Joiner&amp;);
  Joiner&amp; <a href="#Joiner-opeq">operator=</a>(Joiner&amp;&amp;);

  <a href="#Joiner-opbool">explicit operator bool</a>() const noexcept;
  void <a href="#Joiner-assert_valid">assert_valid</a>() const noexcept;
  const Pointer&amp; <a href="#Joiner-implementation">implementation</a>() const noexcept;
  Pointer&amp; <a href="#Joiner-implementation">implementation</a>() noexcept;

  Joiner&amp; <a href="#Joiner-skip_empty">skip_empty</a>(bool value = true) noexcept;

  <a href="#Join">Join</a> <a href="#Joiner-join">join</a>(const <a href="http://en.cppreference.com/w/cpp/container/vector">std::vector</a>&lt;<a href="#StringPiece">StringPiece</a>&gt;&amp; vec) const;
  <a href="#Join">Join</a> <a href="#Joiner-join">join</a>(const <a href="http://en.cppreference.com/w/cpp/container/vector">std::vector</a>&lt;<a href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a>&gt;&amp; vec) const;
  template &lt;typename... Args&gt; <a href="#Join">Join</a> <a href="#Joiner-join">join</a>(Args&amp;&amp;... args) const;

  <a href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a> <a href="#Joiner-join_string">join_string</a>(const <a href="http://en.cppreference.com/w/cpp/container/vector">std::vector</a>&lt;<a href="#StringPiece">StringPiece</a>&gt;&amp; vec) const;
  <a href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a> <a href="#Joiner-join_string">join_string</a>(const <a href="http://en.cppreference.com/w/cpp/container/vector">std::vector</a>&lt;<a href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a>&gt;&amp; vec) const;
  template &lt;typename... Args&gt; <a href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a> <a href="#Joiner-join_string">join_string</a>(Args&amp;&amp;... args) const;

  void <a href="#Joiner-join_append">join_append</a>(std::string* out, const <a href="http://en.cppreference.com/w/cpp/container/vector">std::vector</a>&lt;<a href="#StringPiece">StringPiece</a>&gt;&amp; vec) const;
  void <a href="#Joiner-join_append">join_append</a>(std::string* out, const <a href="http://en.cppreference.com/w/cpp/container/vector">std::vector</a>&lt;<a href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a>&gt;&amp; vec) const;
  template &lt;typename... Args&gt; void <a href="#Joiner-join_append">join_append</a>(std::string* out, Args&amp;&amp;... args) const;
};

}
</pre>

      <p>TODO: fill this in.</p>

      <h3 id="Joiner-ctor">Joiner::Joiner()</h3>

      <p>Constructs a Joiner.</p>

      <ul>
        <li>
          The default constructor creates an empty Joiner.
        </li>
        <li>
          The <code>Pointer</code> constructor creates a non-empty Joiner.
        </li>
        <li>
          The copy constructor creates a Joiner with the same implementation
          and knobs as the copied-from Joiner.
        </li>
        <li>
          The move constructor creates a Joiner with the same implementation
          and knobs as the moved-from Joiner. The moved-from Joiner is left as
          an empty Joiner.
        </li>
      </ul>

      <h3 id="Joiner-opeq">Joiner::operator=()</h3>

      <p>Assigns to this Joiner. The copy and move assignment operators
      function analogously to their respective constructors.</p>

      <h3 id="jimplementation">Implementation</h3>

      <h4 id="Joiner-opbool">Joiner::operator bool()</h4>

      <p>Returns true iff this Joiner is non-empty.</p>

      <h4 id="Joiner-assert_valid">Joiner::assert_valid()</h4>

      <p>Asserts that this Joiner is non-empty.</p>

      <h4 id="Joiner-implementation">Joiner::implementation()</h4>

      <p>Returns the pointer to this Joiner's implementation.</p>

      <h3 id="jfluent">Fluent Setters</h3>

      <h4 id="Joiner-skip_empty">Joiner::skip_empty()</h4>

      <p>Iff <code>value</code> is true, configures this Joiner to skip any
      input item which is an empty string.</p>

      <p>The default is to preserve any empty input items.</p>

      <h3 id="Joiner-join">Joiner::join()</h3>

      <p>Creates a lazy <a href="#Join">Join</a> object.</p>

      <h3 id="Joiner-join_string">Joiner::join_string()</h3>

      <p>Joins its arguments to create a <code>std::string</code> value.</p>

      <h3 id="Joiner-join_append">Joiner::join_append()</h3>

      <p>Joins its arguments and appends them to an existing
      <code>std::string</code> value.</p>
    </section>
    <hr>
    <section>
      <h2 id="Join">Join</h2>

<pre class="codebox">
namespace base {

class Join {
 public:
  <a href="#Join-ctor">Join</a>(const Join&amp;) = default;
  <a href="#Join-ctor">Join</a>(Join&amp;&amp;) noexcept = default;
  Join&amp; <a href="#Join-opeq">operator=</a>(const Join&amp;) = default;
  Join&amp; <a href="#Join-opeq">operator=</a>(Join&amp;&amp;) noexcept = default;

  void <a href="#Join-append_to">append_to</a>(std::string* out) const;
  std::size_t <a href="#Join-length_hint">length_hint</a>() const noexcept;
  <a href="#Join-opstring">operator std::string</a>() const;
};

}
</pre>

      <p>TODO: fill this in.</p>

      <h3 id="Join-ctor">Join::Join()</h3>

      <p>Constructs a Join object. Join is copyable and moveable.</p>

      <h3 id="Join-opeq">Join::operator=()</h3>

      <p>Assigns to a Join object. Join is copyable and moveable.</p>

      <h3 id="Join-append_to">Join::append_to()</h3>

      <p>Computes this Join's output and appends its to the given
      <code>std::string</code> value.</p>

      <h3 id="Join-length_hint">Join::length_hint()</h3>

      <p>Computes the approximate length of this Join's output.</p>

      <h3 id="Join-opstring">Join::operator std::string()</h3>

      <p>Computes this Join's output and returns it.</p>
    </section>
    <hr>
    <section>
      <h2 id="JoinerImpl">JoinerImpl</h2>

<pre class="codebox">
namespace base {

class <strong>JoinerImpl</strong> {
 public:
  virtual ~JoinerImpl() noexcept = default;
  virtual void <a href="#JoinerImpl-glue">glue</a>(<a href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a>* out, <a href="#StringPiece">StringPiece</a> sp, bool first) const = 0;
  virtual std::size_t <a href="#JoinerImpl-hint">hint</a>() const noexcept = 0;

  <s>JoinerImpl(const JoinerImpl&amp;) = delete;</s>
  <s>JoinerImpl(JoinerImpl&amp;&amp;) = delete;</s>
  <s>JoinerImpl&amp; operator=(const JoinerImpl&amp;) = delete;</s>
  <s>JoinerImpl&amp; operator=(JoinerImpl&amp;&amp;) = delete;</s>
};

}
</pre>

      <p>TODO: fill this in.</p>

      <h3 id="JoinerImpl-glue">JoinerImpl::glue()</h3>
      <h3 id="JoinerImpl-hint">JoinerImpl::hint()</h3>
    </section>
  </article>

  <nav id="navbar">
    <p>Waiting for JavaScript...</p>
  </nav>
</body>
</html>
